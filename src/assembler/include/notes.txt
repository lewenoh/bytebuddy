Found in lewen's code:
//	while (count < numChar) {
//char *currLine; // do i need to malloc here or can i realloc with no data
//size_t currLength;
//
//while (lineBuffer[count] != '\n') { // new line reached
//currLength = (currLine == NULL) ? 0 : strlen(currLine); // check that currString has enough of space
//currLine = (char *) (realloc(currLine, currLength + 1)); // reallocate to include new char
//currLine[currLength] = lineBuffer[count];
//count++;
//}

//instrLines = (char **) realloc(instrLines, (instrLineIndex + 1) * sizeof(char *));
//
//currLength = (currLine == NULL) ? 0 : strlen(currLine);
//currLine = (char *) (realloc(currLine, currLength + 1));
//currLine[currLength] = '\0'; // terminating character for the last element of each line.
//
//instrLines[instrLineIndex] =
//currLine;
//
//free(currLine);
//
//count++;
//
//instrLineIndex++;


Lewen's splitlines function before my change:
instructionLinesType *split_lines(FILE *inputFile, char *lineBuffer, int *instrCount) {

    long fileSize;
    int numChar;
    initial_processing(inputFile, &fileSize, &numChar);


	lineBuffer = (char **) malloc(fileSize + 1); // allocating suitable amount of space in lineBuffer.
    assert(lineBuffer != NULL);

    // reading from inputFile to lineBuffer
	int charsRead = fread(lineBuffer, sizeof(char), numChar, inputFile);
    if (charsRead < numChar) { // verifying that read was successful
        fclose(inputFile);
		free(lineBuffer);
        fprintf(stderr, "Error reading from file.\n");
		exit(1);
	}
	lineBuffer[charsRead] = '\0'; // null terminating the buffer

	// processing chars in lineBuffer to split line by line.
    instructionLinesType *instrLines = create_empty_lines();

	char **instrLines = malloc(LINE_CAPACITY * sizeof(char *)); // allocating a suitable amount of space in 2D array instrLines.

	assert(instrLines != NULL);

	size_t instrLineIndex = 0;

    	char *line = strtok(lineBuffer, "\n"); // split the buffer into lines

	while (line != NULL) {
		//instrLines[instrLineIndex] = malloc(sizeof(char *)); // Allocate memory for each line
        	instrLines[instrLineIndex] = (char **) malloc(strlen(line) + 1);
		if (instrLines[instrLineIndex] == NULL) {
            		perror("Error allocating memory");

			for (int i = 0; i < instrLineIndex; i++) {
                		free(instrLines[i]);
            		}
            		free(lineBuffer);
            		free(instrLines);
            		fclose(inputFile);
			exit(1);

        	}
		//instrLines[instrLineIndex] = realloc(instrLines[instrLineIndex], sizeof(*instrLines[instrLineIndex]) + strlen(line));
        	strcpy(*instrLines[instrLineIndex], line); // Copy the line into the array
		*instrCount = *instrCount + 1;
        	instrLineIndex++;
        	line = strtok(NULL, "\n"); // get the next line
    	}

	if (ferror(inputFile)) {
 	       perror("Error reading file");
    	}

    	// Free the allocated memory
	free(lineBuffer);

    	fclose(inputFile);
    	return instrLines;
}

//
// uncomment below if not freed in any function
//	for (int i = 0; i < instrLineIndex; i++) {
//                free(instrLines[i]);
//        }
//        free(instrLines);
//    fclose(outputFile);
//    test_ilines();


Iterate through each instruction in the list.
Read first argument. If it is label then save to symbol table.
Need an instruction count to count excluding labels and .ints.
First address is 0x1, 0x2,0x3... Each address specifies a unique memory address.


Assume that in branch literals, an address can never be a label. Thus there is no need to check whether
the literal is an address or label as get_address called on a address string would always return null.


Tokenisation for instructions.
add	x0, x0, #0x1, lsl #12
Note that optional parameters come last and that all parameters are ', ' separated.
Optional parameters can be detected by seeing how many total high level parameters have been supplied.
ldr !

Idea one: Identify what instruction it is then run tokeniser for that specific instruction.
Based on instruction split a certain number of times. Arg for number of splits.
Check for optional. Based on instruction use optional argument tokeniser.

b and b.cond will require lookup symbol table. Do that later.
str,ldr will require a separate tokeniser for memory addressing.


//   .s file read -> Instruction table, Symbol Table
//   For each instruction, classify.
//   Encode each instruction into binary.
//   Write binary to .bin file.
//  char * test_man = "and x0, x0, x0";
//  token_arr tokenised_test;
//  memcpy(tokenised_test, tokenise_instruction(test_man), sizeof(token_arr));
//  for (int i = 0; i < 4; i++) {
//      printf("Element %d: %s\n", i, tokenised_test[i]);
//  }


//            int j = 0;
//            for (int start = init_index; start < *index; start ++) {
//                (*tokenArr)[i][j] = raw_instr[start];
//                j++;
//            }

char* read_word(instruction c, index i, instruction raw_instr, char * buffer) {
    // Calculate index of first white space character
    while (*c != ' ') {
        // Calculate index.
        i++;
        // Increment pointer.
        c++;
    }
    // i points to the first white space character.

    strncpy(buffer, raw_instr, i+1);
    return buffer;

}

void add_instruction(instruction_array *symbolTable, instruction instr) {

    // Make new instruction
    instruction new_instruction = (instruction)malloc(strlen(instr)+1);
    if (new_instruction == NULL) {
        abort();
    }
    strcpy(new_instruction, instr);

    // Reallocate more memory.
    instruction **instruction_arr = (instruction **)realloc(symbolTable->instructions,
                                                      sizeof(instruction *) * (symbolTable->size+1));
    if (instruction_arr == NULL) {
        free(new_instruction);
        abort();
    }


    symbolTable->instructions = instruction_arr;
    symbolTable->instructions[symbolTable->size] = &new_instruction;
//    *(symbolTable->instructions[symbolTable->size]) = *instruction_entry;
//    instruction_arr[symbolTable->size] = instruction_entry;
    symbolTable->size ++;
}